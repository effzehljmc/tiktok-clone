
### Code Style and Structure
- **Write concise, technically sound TypeScript code** with accurate examples.
- **Use functional and declarative programming patterns** – avoid classes; prefer pure functions.
- **Favor iteration and modularization** over code duplication.
- **Use descriptive variable names** with auxiliary verbs (e.g., `isLoading`, `hasError`).
- **File Structure Guidelines:**
  - Export components separately.
  - Organize subcomponents, helpers, static assets, and TypeScript interfaces in distinct files.
- **Follow Expo's official documentation** for project setup and configuration:  
  [Expo Documentation](https://docs.expo.dev/)

### Naming Conventions
- **Use lowercase with dashes for directory names** (e.g., `components/auth-wizard`).
- **Favor named exports** for components.

### TypeScript Usage
- **Utilize TypeScript for all code;** prefer interfaces over type aliases.
- **Avoid enums;** use maps or objects instead.
- **Employ functional components** along with TypeScript interfaces.
- **Enable strict mode** in TypeScript for enhanced type safety.

### Syntax and Formatting
- **Use the `function` keyword** for pure functions.
- **Avoid unnecessary curly braces** in conditionals; use a concise syntax for simple statements.
- **Write declarative JSX** for your UI.
- **Utilize Prettier** for consistent code formatting.

### UI and Styling
- **Leverage Expo's built-in components** for common UI patterns and layouts.
- **Implement responsive design** using Flexbox and Expo's `useWindowDimensions` to adjust for various screen sizes.
- **Styling Options:**
  - Use `styled-components` or Tailwind CSS (e.g., via [NativeWind](https://www.nativewind.dev/)) for component styling.
- **Implement dark mode support** using Expo's `useColorScheme`.
- **Ensure high accessibility (a11y) standards:**
  - Use ARIA roles and native accessibility props.
- **Adopt performant animation and gesture libraries:**
  - Utilize `react-native-reanimated` and `react-native-gesture-handler`.

### Safe Area Management
- **Use `SafeAreaProvider`** from `react-native-safe-area-context` for global safe area management.
- **Wrap top-level components with `SafeAreaView`** to handle notches, status bars, and other insets on both iOS and Android.
- **Utilize `SafeAreaScrollView`** for scrollable content to ensure safe area boundaries are respected.
- **Avoid hardcoding paddings or margins** for safe areas; rely on `SafeAreaView` and its context hooks.

### Performance Optimization
- **Minimize usage of `useState` and `useEffect`** – favor Context and Reducers for complex state management.
- **Optimize the app startup:**  
  - Use Expo's `AppLoading` and `SplashScreen` for an improved launch experience.
- **Optimize images:**
  - Use the WebP format where supported, include size metadata, and implement lazy loading with `expo-image`.
- **Implement code splitting and lazy loading** for non-critical components using React's `Suspense` and dynamic imports.
- **Prevent unnecessary re-renders:**
  - Memoize components and use `useMemo` and `useCallback` judiciously.
- **Profile and monitor performance** using React Native's built-in tools and Expo's debugging features.

### Navigation
- **Utilize `react-navigation`** for routing and navigation; follow best practices for stack, tab, and drawer navigators.
- **Leverage deep linking and universal links** for enhanced user engagement.
- **Implement dynamic routing** with `expo-router` for flexible navigation handling.

### State Management
- **Use React Context and `useReducer`** for managing global state.
- **Adopt `react-query`** for data fetching and caching to reduce redundant API calls.
- **For more complex state requirements:**
  - Consider state management libraries such as Zustand or Redux Toolkit.
- **Handle URL search parameters** using libraries like `expo-linking` if necessary.

### Error Handling and Validation
- **Utilize Zod** for runtime validation and error handling.
- **Implement robust error logging** using Sentry or a similar service.
- **Prioritize error handling:**
  - Handle errors at the start of functions.
  - Use early returns to avoid deeply nested conditionals.
  - Avoid unnecessary `else` statements; prefer the if-return pattern.
  - Implement global error boundaries to catch unexpected errors.
- **Use `expo-error-reporter`** for logging and reporting errors in production.

### Testing
- **Write unit tests** using Jest and React Native Testing Library.
- **Implement integration tests** for critical user flows with Detox.
- **Utilize Expo's testing tools** for running tests across different environments.
- **Consider snapshot testing** for components to ensure UI consistency.

### Security
- **Sanitize user inputs** to prevent XSS attacks.
- **Use `react-native-encrypted-storage`** for securely storing sensitive data.
- **Ensure secure API communication** using HTTPS and proper authentication.
- **Follow Expo's Security Guidelines:**  
  [Expo Security Guidelines](https://docs.expo.dev/guides/security/)

### Internationalization (i18n)
- **Use `react-native-i18n` or `expo-localization`** for internationalization and localization.
- **Support multiple languages and RTL layouts.**
- **Ensure text scaling and font adjustments** for accessibility.

### Key Conventions
1. **Expo Managed Workflow:**  
   - Rely on Expo's managed workflow for streamlined development and deployment.
2. **Mobile Web Vitals:**  
   - Prioritize load times, smooth animations, and responsiveness.
3. **Environment Variables:**  
   - Use `expo-constants` for managing environment variables and configuration.
4. **Device Permissions:**  
   - Leverage `expo-permissions` to gracefully handle device permissions.
5. **OTA Updates:**  
   - Implement `expo-updates` for over-the-air updates.
6. **Deployment & Publishing:**  
   - Follow Expo's best practices for app distribution and publishing:  
     [Expo Distribution](https://docs.expo.dev/distribution/introduction/)
7. **Platform Compatibility:**  
   - Test extensively on both iOS and Android to ensure full compatibility.

### API Documentation
- **Follow Expo's official documentation** for project setup and configuration:  
  [Expo Documentation](https://docs.expo.dev/)

### Database and Supabase
- **Use Prisma as Primary ORM:**
  - Enable TypeScript integration with Prisma Client
  - Follow schema naming conventions:
    - Use snake_case for database fields
    - Use PascalCase for model names
    - Use descriptive relation names
  - Enable PostgreSQL extensions via preview features
  - Use UUID as primary key with uuid-ossp extension
  - Implement cascading deletes where appropriate
  - Maintain schema in `prisma/schema.prisma`

- **Prisma Best Practices:**
  - Generate types with `prisma generate`
  - Use transactions for related operations
  - Implement proper error handling for database operations
  - Leverage Prisma Studio for data management
  - Keep schema changes in version control

- **Use Supabase Branching for Development:**
  - Create preview branches for testing database changes
  - Use `supabase db diff` to generate migration files

### Database Migration Best Practices:
- Keep migrations sequential and atomic
- Use descriptive names for migration files
- Test migrations in preview branches
- Handle rollbacks gracefully

### Seeding Data:
- Maintain `seed.sql` for preview environments
- Keep seed data minimal but sufficient for testing
- Use consistent test data across environments

---

Diese Richtlinien helfen dir dabei, eine saubere, wartbare und performante Codebasis für deinen TypeScript-/React Native-/Expo-Projekt zu entwickeln – ideal für mobile UI-Entwicklung auf macOS.